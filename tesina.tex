% !TeX spellcheck = it_IT
\documentclass[]{article}
\usepackage{color, soul}
\newcommand{\hlc}[2][yellow]{ {\sethlcolor{#1} \hl{#2}} }
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{graphicx}



% Title Page
\title{PASTEL}
\author{{Augello Andrea} \and {Bafumo Francesco} \and{La Martina Marco}}


\begin{document}
\maketitle
\tableofcontents


\section{Introduzione}
PASTEL è stato pensato come un linguaggio di scripting per gestire e coordinare le interazioni tra dispositivi IoT basati su TCP.\\
L'utilizzo di PASTEL può essere vantaggioso in sistemi ciberfisici complessi che necessitano una conoscenza dello stato globale del sistema per coordinarsi. Infatti il sitema potrebbe includere dispositivi con risorse limitate e scarse capacità computazionali, che quindi non sono in grado di memorizzare lo stato del resto dei sensori ed effettuare decisioni complesse. 

Un altro contesto in cui PASTEL può essere utile è testare in modo replicabile il corretto comportamento interattivo di un sistema ciberfisico: il linguaggio proposto infatti può facilmente simulare l'output di molti sensori ed inviarlo agli attuatori.

Il resto della \hl{tesina} è strutturato come segue: la sezione~\ref{section:stato-arte} illustra il contesto in cui si colloca il linguaggio proposto, nella sezione~\ref{section:descrizione} vengono analizzati i dettagli implementativi, nella sezione~\ref{section:caratteristiche-linguaggio} si illustrano le caratteristiche di PASTEL e degli esempi di applicazioni, infine nella sezione~\ref{section:conclusioni} vengono riepilogati i punti principali del lavoro svolto.

\section{Stato dell'arte}\label{section:stato-arte}

I dispositivi IoT comunemente eseguono protocolli semplici come CoAP, REST e MQTT~\cite{tandale2017empirical}. \hlc[cyan]{[Inserire descrizione dei protocolli, magari qualche altra citazione]}

Il linguaggio proposto può facilmente essere utilizzato con i protocolli precedenti, eccetto CoAP poiché basato su UDP. L'ambiente target principale però è quello dei dispositivi in grado di eseguire codice simbolico~\cite{gaglio2017dc4cd} e su questi si incentreranno di casi d'uso nella sezione \ref{subsection:casi-d_uso}.  

[...]L'equivalente di \texttt{expect}~\cite{libes1991expect, libes1990expect} per reti di sensori wireless (WSN).

Alla luce di quanto detto, con questo linguaggio ci prefiggiamo l'obbiettivo di fornire uno strumento che permette di interfacciarsi con facilità e in modo affidabile con dispositivi IoT, [...]

\section{Descrizione del progetto}\label{section:descrizione}
\subsection{Analisi dei requisiti}
\subsection{Scelte progettuali}
\section{Caratteristiche del linguaggio}\label{section:caratteristiche-linguaggio}
\subsection{Grammatica}
\subsection{Descrizione del parser}
\subsection{Casi d'uso}\label{subsection:casi-d_uso}
\subsubsection{Network discovery}\label{subsubsection:net-disc}
In una rete di sensori generalmente è necessario che ogni nodo sappia quali sono i suoi vicini e come raggiungerli, a questo scopo sono stati sviluppati un grande numero di protocolli~\cite{narten1998neighbor, kandhalu2010u, alsa2012secure}.

In questo caso d'uso mostriamo come, con un codice relativamente compatto, a partire dalla conoscienza dell'indirizzo di un singolo nodo indicato con \texttt{root}, sia possibile ricostruire la topologia della porzione di rete connessa al nodo \texttt{root}.\\
Nel codice mostrato in~\ref{listing:net-disc} ogni nodo viene interrogato per ottenere la lista dei suoi vicini tramite la procedura \texttt{find\_neighbours}. Tutti i vicini del nodo che non sono già stati individuati precedentemente vengono aggiunti ad una lista di nodi noti.

Ogni nodo comunica la lista dei suoi vicini restituiendo in formato testuale indirizzo IP e numero di porta ai quali sono raggiungibili, separando i vari nodi con delle virgole. Il linguaggio PASTEL mette a disposizione funzioni bultin che permettono in modo estremamente semplice, a partire dai dati forniti in questo formato, di ottenere una lista PASTEL e convertire tutte le stringhe in device utilizzabili all'interno del programma.

L'algoritmo termina automaticamente nonappena l'ultimo dei nodi noti interrogato non restituisce nodi nuovi, a quel punto si saranno individuati tutti i nodi raggiungibili a partire da \texttt{root}.

Per semplicità si assume che il calcolatore che esegue il programma abbia un range di comunicazione molto superiore ai nodi della rete, e che possa quindi raggiungerli in un singolo hop, una strategia più generale dovrebbe ovviamente prevedere la costruzione di messaggi di routing.

\lstinputlisting[firstline=3, lastline=41, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Source code of \lstname}, label={listing:net-disc}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]{testfiles/network_discovery.pa}

\subsubsection{Publish-Subscribe}\label{subsubsection:pub-sub}

Come visto precedentemente in~\cite{tandale2017empirical} il modello Publish-Subscribe è molto comune come protocollo di comunicazione nel campo IoT. Nel listato~\ref{listing:sub} mostriamo come PASTEL permetta con facilità di interrogare una lista di nodi per ottenere i topic a cui ogni nodo intende fare il subscribe, dopo questo step di configurazione è immediato poter mandare a tutti i nodi iscritti ad un topic un determinato messaggio.


\lstinputlisting[firstline=3, lastline=62, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Source code of \lstname}, label={listing:sub}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
 ]{testfiles/subscriber.pa}


Con questo framework diventa estremamente facile per un nodo comunicare un messaggio da mandare a tutti i nodi iscritti ad un topic, come mostrato nel listato~\ref{listing:pub}.

Il programma si aspetta un input del tipo ``\texttt{<lista di topic> :TOPICS <messaggio>}'', la parte di messaggio che precede ``\texttt{:TOPICS}'' è interpretata come una lista di topic separati da virgole, il messaggio che segue quel tag, invece, verrà inviato a tutti i nodi che si sono precedentemente iscritti ad almeno uno di quei topic.

\lstinputlisting[firstline=3, lastline=62, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Source code of \lstname}, label={listing:pub}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{testfiles/publisher.pa}

Lo schema di funzionamento illustrato può ovviamente essere ulteriormente raffinato impedendo l'iscrizione multipla ad uno stesso topic e aggiungendo controlli per evitare di inviare più volte uno stesso messaggio un nodo iscritto a più topic, o al nodo che ha originato il messaggio. Inoltre è possibile prevedere la possibilità di cancellare le iscrizioni o modificarle periodicamente.

\subsection{Risultati ottenuti}\label{subsection:risultati}

Il codice mostrato nelle sezioni~\ref{subsubsection:net-disc} e~\ref{subsubsection:pub-sub} mostra la potenzialità di essere integrato in un unico sistema software che, inserito in una rete, a partire dalla conoscenza di un singolo nodo, riesce a ricostruire la topologia della rete raggiungibile e gestire il funzionamento di un protocollo non banale del tipo publish-subscribe, dimostrando l'applicabilità del linguaggio proposto all'interno del contesto target. 

\begin{table}[htbp]
	\centering
	\resizebox{\columnwidth}{!}{
	\begin{tabular}{c| cc | cc}
		\hline
		                   & \multicolumn{2}{c}{{\normalsize Ciclo iterativo }} & \multicolumn{2}{c}{{\normalsize Ciclo iterativo }} \\ \cline{2-5}
		Numero di messaggi & Tempo totale (s) &         Tempo netto (s)         & Tempo totale (s) &         Tempo netto (s)         \\ \hline
		        10         & 1.563            &              0.479              & 1.531            &              0.461              \\
		        50         & 2.629            &              0.517              & 1.554            &              0.484              \\
		       100         & 1.539            &              0.467              & 1.654            &              0.495              \\
		       1000        & 2.659            &              0.544              & 1.726            &              0.581              \\
		      10000        & 47.178           &              1.278              & 5.542            &              1.428              \\ \hline
	\end{tabular}}
	\caption{Tempo necessario per l'invio di un numero crescente di messaggi}
	\label{table:metric_average_reliable}
\end{table}
\section{Conclusioni}\label{section:conclusioni}




\bibliographystyle{unsrt}
\bibliography{references}

\end{document}          

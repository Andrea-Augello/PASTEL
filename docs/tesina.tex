% !TeX spellcheck = it_IT
\documentclass[10pt]{article}
\usepackage{color, soul}
\newcommand{\hlc}[2][yellow]{ {\sethlcolor{#1} \hl{#2}} }
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[italian]{babel}
\usepackage[hidelinks]{hyperref}


% Title Page
\title{PASTEL}
\author{{Augello Andrea} \and {Bafumo Francesco} \and{La Martina Marco}}


\begin{document}
\maketitle
\tableofcontents
\clearpage


%% INTRODUZIONE

\section{Introduzione}
PASTEL (Protocol Agnostic Synchronous Transmission Eclectic Language) è stato pensato come un linguaggio di scripting per gestire e coordinare le interazioni tra dispositivi IoT basati su TCP.\\
L'utilizzo di PASTEL può essere vantaggioso in sistemi ciberfisici complessi che necessitano una conoscenza dello stato globale del sistema per coordinarsi. Infatti il sistema potrebbe includere dispositivi con risorse limitate e scarse capacità computazionali, che quindi non sono in grado di memorizzare lo stato del resto dei sensori ed effettuare decisioni complesse. 

Un altro contesto in cui PASTEL può essere utile è testare in modo replicabile il corretto comportamento interattivo di un sistema ciberfisico: il linguaggio proposto infatti può facilmente simulare l'output di molti sensori ed inviarlo agli attuatori.

Il resto della relazione è strutturato come segue: la sezione~\ref{section:stato-arte} illustra il contesto in cui si colloca il linguaggio proposto, nella sezione~\ref{section:descrizione} vengono analizzati i dettagli implementativi, nella sezione~\ref{section:caratteristiche-linguaggio} si illustrano le caratteristiche di PASTEL e degli esempi di applicazioni, infine nella sezione~\ref{section:conclusioni} vengono riepilogati i punti principali del lavoro svolto.


%% STATO DELL'ARTE

\section{Stato dell'arte}\label{section:stato-arte}

I dispositivi IoT comunemente eseguono protocolli semplici come CoAP, REST e MQTT~\cite{tandale2017empirical}. 

Constrained Application Protocol (CoAP) è un   protocollo di trasferimento web specializzato da utilizzare con nodi o reti con risorse limitate (ad es. reti a bassa potenza, senza trasferimento affidabile dei dati). I nodi hanno spesso microcontrollori  a 8 bit con piccole quantità di ROM e RAM, mentre reti con risorse limitate come IPv6 su Low-Power Wireless Personal Area  (6LoWPANs) hanno spesso elevati tassi di errore dei pacchetti e un tipico throughput di 10 s di kbit/s. Il protocollo è progettato per applicazioni  machine-to-machine (M2M) come smart energy e domotica.~\cite{shelby2014constrained}.

Representational State Transfer (REST) è uno tipo di architettura per i sistemi distribuiti. L'espressione representational state transfer e il suo acronimo, REST, furono introdotti nel 2000 nella tesi di dottorato di Roy Fielding, uno dei principali autori delle specifiche dell'Hypertext Transfer Protocol (HTTP), e vennero rapidamente adottati dalla comunità di sviluppatori Internet.
Il termine REST rappresenta un sistema di trasmissione di dati su HTTP senza ulteriori livelli, quali ad esempio SOAP. I sistemi REST non prevedono il concetto di sessione, ovvero sono stateless.
L'architettura REST si basa su HTTP. Il funzionamento prevede una struttura degli URL ben definita che identifica univocamente una risorsa o un insieme di risorse e l'utilizzo dei verbi HTTP specifici per il recupero di informazioni (GET), per la modifica (POST, PUT, PATCH, DELETE) e per altri scopi (OPTIONS, ecc.)~\cite{fielding2000architectural}.

MQTT è un protocollo di connettività machine-to-machine (M2M) / "Internet of Things". È stato progettato come un trasporto di messaggistica estremamente leggero. È utile per le connessioni  remote in cui è richiesto un codice ridotto e/o l'ampiezza di banda della rete è limitata. Ad esempio, è stato utilizzato nei sensori che comunicano con un intermediario tramite collegamento satellitare, attraverso occasionali connessioni dial-up con operatori sanitari e in una gamma di scenari di automazione domestica e piccoli dispositivi. È ideale anche per le applicazioni mobili a causa delle sue dimensioni ridotte, basso consumo energetico, pacchetti di dati ridotti al minimo e distribuzione efficiente delle informazioni a uno o più ricevitori~\cite{banks2019mqtt}.\\



Il linguaggio proposto può facilmente essere utilizzato con il protocollo REST essendo basato su HTTP, un protocollo di livello applicazione che utilizza solo testo. CoAP, utilizzando UDP come protocollo di livello trasporto, non è compatibile con l'ambiente PASTEL. MQTT si appoggia al TCP, tuttavia è basato sull'invio di codice binario, quindi non è direttamente implementabile in PASTEL a meno di utilizzare particolari tecniche di encoding~\cite{josefsson2006base16}, in quel caso sarebbe certamente possibile, ma non è il tipo di applicazione verso cui è orientato il linguaggio.

L'ambiente target principale è quello dei dispositivi in grado di eseguire codice simbolico~\cite{gaglio2017dc4cd}. L'utilizzo di codice simbolico (e.g. in dispositivi che eseguono un interprete FORTH~\cite{brodie2004thinking}) permette di generare in modo automatico istruzioni valide per tutti i dispositivi presi in considerazione, indipendentemente dall'architettura hardware sottostante.
Inoltre, essendo possibile definire nuove parole su nodi già installati ( utilizzando quelle precedentemente definite) è possibile, a partire da delle primitive legate alle trasmissioni, abilitare tutti i nodi della rete all'esecuzione di protocolli arbitrari in una fase di inizializzazione in cui viene comunicato il codice simbolico necessario. 

Con un approccio simbolico diventa anche possibile supportare protocolli normalmente basati su bytecode come MQTT nativamente~\cite{gaglio19interoperable}.
Essendo questo il campo di applicazione principale, su questo si incentreranno di casi d'uso nella sezione \ref{subsection:casi-d_uso}.\\



PASTEL può essere pensato come un linguaggio per generare programmi che possano mandare e ricevere messaggi testuali tramite TCP, condizionati e iterati facilmente. Questo concept può essere pensato come l'equivalente di \texttt{expect}~\cite{libes1991expect, libes1990expect, libes1995exploring} per reti di sensori wireless (WSN).

\texttt{expect} è un programma che "parla" con altri programmi interattivi secondo uno script. Seguendo lo script, \texttt{expect} sa cosa ci si può aspettare da un programma e quale dovrebbe essere la risposta corretta. Un linguaggio interpretato fornisce ramificazioni e strutture di controllo di alto livello per dirigere il dialogo. Inoltre, l'utente può assumere il controllo e interagire direttamente quando lo desidera, in seguito restituendo il controllo allo script.

Il tool \texttt{expect} è basato sul linguaggio Tcl. Tcl fornisce il controllo per il flusso (ad esempio, if, for, break), la valutazione delle espressioni e diverse altre funzioni come la ricorsione, definizione delle procedure, ecc.. 

Tcl è stato uno dei primi linguaggi "dinamici" a diventare popolare, vedendo un uso diffuso a partire dai primi anni '90. Tcl ha trovato ampio successo in molti campi, e le distribuzioni di Tcl spaziano da dispositivi integrati come router, a infrastrutture di back-end distribuite.~\cite{nadkarni2017tcl}.\\

Alla luce di quanto detto, con questo linguaggio ci prefiggiamo l'obiettivo di fornire uno strumento che permette di interfacciarsi con facilità e in modo affidabile con dispositivi IoT, con la possibilità di potere iterare le operazioni, manipolare i dati con estrema facilità e definire delle routine da potere effettuare in maniera condizionata.


%% DESCRIZIONE DEL PROGETTO

\section{Descrizione del progetto}\label{section:descrizione}

Il linguaggio PASTEL nasce con lo scopo di agevolare la programmazione di software che si occupano di gestire dispositivi in ambiente IoT. Viene proposto un interprete per il linguaggio PASTEL, piuttosto che un compilatore, sia per la minore complessità implementativa, che per favorire l'interattività delle operazioni che vengono normalmente svolte in questo contesto. Per dare la possibilità al programmatore di effettuare tutte le manipolazioni ai dati del caso, vi sono quattro tipi primitivi, ovvero \texttt{ int, real, string} e \texttt{address}. La possibilità di poter definire nuovi tipi non è consentita, per non dover appesantire inutilmente il linguaggio, poiché nel contesto in cui viene utilizzato, non è un requisito fondamentale. 

Il tipo \texttt{address} è il tipo che caratterizza il linguaggio poiché è grazie al suo utilizzo che sono semplificate molte operazioni che un linguaggio da utilizzare in ambiente IoT deve supportare. 

Considerando inoltre che PASTEL si pone in un contesto in cui i dati scambiati tra i device sono delle sequenze di caratteri, non poteva che essere presente il tipo \texttt{string}. Le stringhe vengono trattate come un tipo primitivo immutabile e non è consentito l'accesso diretto al singolo carattere. Per potere ottenere i singoli caratteri, può però essere utilizzata la funzione \texttt{s2l} che restituisce un valore di tipo \texttt{list}, ovvero una lista dei singoli caratteri (rappresentati come stringhe di lunghezza 1) della stringa data in input alla funzione. 

La separazione tra \texttt{int} e \texttt{real} è stata pensata per evitare problemi dovuti all'imprecisione della rappresentazione in virgola mobile~\cite{benz2012dynamic}. 

Il tipo \texttt{device} è un tipo composto da \texttt{address} e \texttt{int}, poiché un device è caratterizzato dal suo indirizzo IP e da un numero di porta, dato che il linguaggio poggia le sue basi sul protocollo TCP/IP. 

Il tipo \texttt{list} viene pensato per rendere facili ed intuitive le operazioni di iterazione. Questo tipo di dato infatti caratterizza liste eterogenee che possono contenere elementi di qualsiasi tipo, tranne un'altra lista. Non è consentito infatti l'uso di liste innestate. È però possibile scrivere una funzione in PASTEL, come quella riportata di seguito, per fare un inserimento con flattening, potendo così inserire gli elementi di una lista all'interno di un'altra. 
\clearpage
\begin{verbatim}
  def flat_insert(a,b,pos){
    int i = 0;
    for(item in b){
        insert(a,item,pos+i);
        i=i+1;   
    }
    a;
}
\end{verbatim}

Non è presente la definizione degli array, la cui introduzione nel linguaggio sarebbe risultata ridondante poiché tutte le operazioni consentite sugli array possono essere fatte con le liste. È infatti consentita anche la possibilità di accedere agli elementi della lista tramite la loro posizione con i selettori normalmente utilizzati sugli array: ``\texttt{nome\_lista[index]}''.\\
Vi è un grande vantaggio nell'utilizzo delle liste, ovvero la possibilità di iterare per ogni elemento della lista tramite il costrutto \texttt{foreach}. La variabile di controllo viene inizializzata all'avvio del ciclo, al termine viene eliminata e non è più referenziabile. Inoltre all'interno del ciclo può essere modificata (e.g. tramite assegnamento).

Per quanto riguarda le funzioni, è possibile sia utilizzare delle funzioni già presenti nel linguaggio, trattate nelle sezione ~ref{subsection:fun}, ma è anche possibile definirne di nuove. I nomi delle funzioni built-in sono parole riservate e quindi non è possibile ridefinirle. Anche quelle definite dall'utente per semplicità implementativa non sono ridefinibili e non è consentito definire una funzione all'interno della definizione di un'altra funzione. Non è 
richiesta la definizione del tipo dei parametri formali, l'onere di gestire la coerenza dei tipi è lasciato al programmatore, che ha quindi la possibilità di creare funzioni che non sono vincolate dai tipi dei parametri formali. Un esempio è mostrato nel listato~\ref{listing:conditional_declaration}. Inoltre i parametri alle funzioni sono passati per copia e la valutazione di eventuali espressioni passate come parametri reali viene effettuata al momento della chiamata alla funzione, non quando i parametri formali vengono utilizzati nel corpo della funzione(eager evaluation).

Il tipo di una variabile deve essere definito al momento della dichiarazione, e non è consentita la modifica. Questo consente di scrivere programmi più robusti e dal debug più semplice. Inoltre al momento della dichiarazione, alla variabile viene assegnato un valore di default per evitare inconsistenze sui dati.

Per non limitare la potenza del linguaggio, le funzioni definite dall'utente possono restituire tipi di dati diversi (una forma primitiva di overloading indipendente dal contesto). In questi casi si possono utilizzare le liste eterogenee per memorizzare i valori restituiti ed eseguire operazioni diverse in base al tipo, come precedentemente dimostrato nel listato~\ref{listing:conditional_declaration}. 

I valori di ritorno delle funzioni corrispondono all'ultimo valore calcolato all'interno della funzione, senza bisogno di esplicitare direttamente cosa la funzione debba restituire. Questo evita salti e interruzioni dell'esecuzione che peggiorano la leggibilità del codice~\cite{dijkstra1968letters}.

Esiste la possibilità di passare file di input (con estensione \texttt{.pa}) all'interprete in modo da eseguire i sorgenti. Dopo di ciò viene restituito il controllo all'interprete. Un altro modo per includere file sorgente è quella di utilizzare la direttiva di inclusione, eseguita in fase di lexing per non rendere possibili include condizionali, potenzialmente ambigui e con comportamento imprevedibile.

Le variabili sono definite con scope limitato alla funzione in cui vengono dichiarate. Una funzione può accedere a tutti i simboli definiti in scope più ampi, ma per discriminare i riferimenti a variabili locali dai riferimenti a variabili di scope più ampio, non viene consentita la dichiarazione implicita delle variabili, quindi la ricerca nelle tabelle dei simboli avviene nel momento in cui le espressioni vengono valutate (scoping dinamico), e non durante il lexing, differentemente dall'implementazione suggerita dal libro di testo~\cite{levine2009flex}. Se una variabile viene definita fuori da una funzione avrà scope globale e la sua vita terminerà alla chiusura dell'interprete.

I cicli iterativi condividono lo scope della funzione in cui vengono eseguiti per ragioni di performance, definire quindi una variabile all'interno di un ciclo porta ad una condizione di errore, poiché dalla seconda iterazione la variabile risulterà già definita.\\


\lstinputlisting[firstline=1, lastline=62, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Esempio di codice PASTEL in cui vengono utilizzate funzioni con tipo di ritorno variabile e dichiarazioni condizionali}, label={listing:conditional_declaration}, breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}
]{../testfiles/conditional_declaration.pa}

%% CARATTERISTICHE DEL LINGUAGGIO

\section{Caratteristiche del linguaggio}\label{section:caratteristiche-linguaggio}

	%% GRAMMATICA
\subsection{Grammatica}

\textbf{Tipi}
Il linguaggio PASTEL possiede sia tipi primitivi che composti. I tipi primitivi sono:
\begin{itemize}
\item \texttt{int}, utilizzato per rappresentare i numeri interi
\item \texttt{real}, utilizzato per rappresentare i numeri in virgola mobile
\item \texttt{string}, utilizzato per rappresentare le stringhe di caratteri
\item \texttt{address}, utilizzato per rappresentare gli indirizzi IPv4
\end{itemize}

I tipi composti sono invece:
\begin{itemize}
\item \texttt{device}, prodotto cartesiano tra i tipi address e int 
\item \texttt{list}, tipo ricorsivo 
\end{itemize}

\clearpage
\textbf{Strutture di controllo}
Il linguaggio fornisce la possibilità di usare sia comandi condizionali che comandi iterativi. I comandi condizionali sono i classici:
\begin{itemize}
\item \texttt{if ( condition ) \{ instructions \}}
\item \texttt{if ( condition ) \{ instructions \} else \{ instructions \}}
\end{itemize}
I comandi iterativi invece sono:
\begin{itemize}
\item \texttt{while ( condition ) \{ instructions \}}
\item \texttt{for ( var in list ) \{ instructions \} }
\end{itemize}
Nell'espressione \texttt{while} si itera indefinitivamente finché la condition è diversa da 0, nel \texttt{for} invece si itera per ogni elemento contenuto nella lista.\\

\textbf{Operazioni}\\
Il linguaggio consente le seguenti operazioni: somma, sottrazione, moltiplicazione, divisione, and e or logici, e comparazioni ( ==, !=, >, >=, <, <=). Le combinazioni di tipi consentite per ogni operatore sono riassunte nella tabella~\ref{table:operatori}. Le comparazioni e gli operatori logici restituiscono sempre degli int, tutti gli altri operatori restituiscono un valore del tipo della colonna, tranne la moltiplicazione \texttt{int * string} equivalente a \texttt{string * int}. \\

\begin{table}
	\centering
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		V1\textbackslash V2 &        int         &    real     &  string  & address & device & list \\ \hline
		        int         & + - * / or and CMP &             &    *     &   + -      &        &      \\ \hline
		       real         &                    & + - / * CMP &          &         &        &      \\ \hline
		      string        &         *          &             & +    CMP &         &        &      \\ \hline
		      address       &        + -         &             &          &   CMP   &        &      \\ \hline
		      device        &                    &             &          &         &  CMP   &      \\ \hline
		       list         &                    &             &          &         &        &  +   \\ \hline
	\end{tabular}
	\caption{Operazioni consentite dal linguaggio, sono da intendersi come V1 <operatore> V2. Con CMP si indicano le operazioni di comparazione}
	\label{table:operatori}
\end{table}


\textbf{Selettori}\\
Il tipo device, come già accennato precedentemente, è un prodotto cartesiano tra \texttt{address} e \texttt{int}. Infatti un device è caratterizzato da un indirizzo IP e un numero di porta. Per potere accedere al singolo campo del record, vengono utilizzati i selettori \texttt{.address} e \texttt{.port}. I campi di un device sono accessibili con i suddetti selettori, ma non è consentito un aggiornamento selettivo, impedendo di modificare un device verso il quale è aperta una connessione. È comunque consentito l'aggiornamento totale. Per la creazione di un valore di tipo device si utilizza la seguente sintassi ``\texttt{<address>:<port>}''.\\

\textbf{Funzioni}\\
Il linguaggio PASTEL offre al programmatore un'ampia varietà di funzioni built-in, che verranno illustrate nella sezione \ref{subsection:fun}. Chiaramente è anche possibile estendere il linguaggio definendone di nuove tramite la sintassi ``\texttt{def nome\_funzione ( parametri\_formali ) \{ istruzioni \}}''.
\\


	%% PARSER
\subsection{Parser}

Un requisito del progetto è di creare il linguaggio con i tools Bison e Flex~\cite{levine2009flex}, due strumenti per costruire programmi che gestiscano input strutturati. Flex si occupa dell'analisi lessicale (lexing) mentre Bison si occupa dell'analisi della sintassi (parsing). L'output dei due tools è un parser di tipo LALR(1) che effettua un parsing bottom-up, con cui è possibile gestire  produzioni left-recursive, utilizzando Bison per generare il parser e Flex per riconoscere i token nella fase di lexing.

Riportiamo di seguito le regole di produzione in formato BNF del linguaggio proposto:

\begin{lstlisting}
<program>::= 
	| <program> <stmt>
	| <program> DEF NAME '(' <symlist> ')' '{' <list> '}'  

<stmt>::= IF '(' <exp> ')' '{' <list> '}' 
	| IF '(' <exp> ')' '{' <list> '}' ELSE '{' <list> '}'  
	| WHILE '(' <exp> ')' '{' <list> '}'    
	| FOR '(' NAME IN <exp> ')' '{' <list> '}'  
	| <exp> ';'
	| <decl> ';'

<list>::=
	| stmt <list> 

<exp>::= '(' <exp> ')'         
	| FUNC '(' <explist> ')' 
	| VALUE              
	| <exp> ':' <exp>         
	| <exp> '+' <exp>         
	| <exp> '-' <exp>         
	| <exp> '*' <exp>          
	| <exp> '/' <exp>          
	| <exp> AND <exp>          
	| <exp> OR <exp>           
	| '-' <exp>
	| NAME'[' <exp> ']'          
	| NAME                 
	| <exp> CMP <exp>          
	| <exp> ADDR             
	| <exp> PORT             
	| NAME '(' explist ')' 

<decl>::= TYPE NAME          
	| NAME '=' <exp>                    
	| NAME '[' <exp> ']' '=' <exp>
	| TYPE NAME '=' <exp>     

<explist>::=
	| <exp>
	| <exp> ',' <explist> 

<symlist>::= 
	| NAME       
	| NAME ',' <symlist>
\end{lstlisting}

Le regole di produzione per \texttt{<exp>} sembrerebbero ambigue, infatti una stessa sequenza di operatori potrebbe essere rappresentata da più alberi di parsing. È generalmente possibile riscrivere la grammatica per eliminare l'ambiguità, però Bison mette a disposizione degli strumenti che permettono di specificare la precedenza degli operatori disambiguando la grammatica e scartando automaticamente gli alberi di parsing non validi, consentendo l'utilizzo di una grammatica più semplice e compatta.

In figura~\ref{fig:parser_simple} viene riportato l'automa a stati finiti generato da Bison su una versione ridotta della grammatica per fornire un'idea generale della struttura di un programma grammaticalmente corretto. Questa grammatica semplificata rimuove delle regole di produzione ricorsive per ridurre il numero di stati, migliorando la leggibilità. In appendice si riporta il grafo della grammatica completa.\\

\begin{figure}
	\centering
	\resizebox{\columnwidth}{!}{
		\includegraphics{sources/parser_simple}}
	\caption{Grafo del FSA generato utilizzando  GNU Bison 3.5.4 XML Automaton Report su una struttura fortemente semplificata per facilitare la rappresentazione. La grammatica completa non presenta conflitti shift/reduce e reduce/reduce.}
	\label{fig:parser_simple}
\end{figure}

	%% LEXER
\subsection{Lexer}

Per quanto riguarda la struttura del lexer, vengono utilizzate delle regex per matchare gli identificatori di ogni tipo del linguaggio, i valori consentiti per ogni tipo, i nomi delle variabili, costanti proprie del linguaggio, l'inserimento di commenti, simboli per la comparazione, operazioni consentite sui tipi, i simboli consentiti, le funzioni built-in del linguaggio, le direttive di preprocessing, i selettori e le strutture di controllo. Queste espressioni regolari sono state utilizzate anche per creare un package di syntax highlighting per l'editor di testo ``Atom'' disponibile open-source online: \textcolor{blue}{\underline{\url{https://atom.io/packages/language-PASTEL}}}\\\\

\textbf{Tipi}
\begin{lstlisting}[breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}]
int	"int"
real	"real"
address	"address"
string	"string"
list	"list"
device	"device"
\end{lstlisting}

\textbf{Valori}
\begin{lstlisting}[breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}]
int	[0-9]+
real	[0-9]+\.[0-9]+
address	((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))|"localhost"
string	\".*\"
\end{lstlisting}

\textbf{Nomi variabili}
\begin{lstlisting}[breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}]
nomi	[a-zA-Z_][a-zA-Z0-9_]*
\end{lstlisting}

\textbf{Costanti}
\begin{lstlisting}[breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}]
newline	"NL"
true	"TRUE"
false	"FALSE"
\end{lstlisting}

\textbf{Commenti}
\begin{lstlisting}[breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}]
inline	"\\".*
block	"/*"[^*\/]*"*/"
\end{lstlisting}

\textbf{Comparazioni}
\begin{lstlisting}[breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}]
maggiore		">"
minore			"<"
diverso			"!="
uguale			"=="
maggiore o uguale	">="
minore o uguale		"<="
\end{lstlisting}

\textbf{Operazioni}
\begin{lstlisting}[breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}]
and 		"and"
or		"or"
somma		"+"
differenza	"-"
moltiplicazione	"*"
divisione	"/"
assegnamento	"="
\end{lstlisting}

\textbf{Simboli}
\begin{lstlisting}[breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}]
,			","
;			";"
{			"{"
}			"}"
[			"["
]			"]"
(			"("
)			")"
spazi e tabulazioni	[ \t]
ritorno a capo		"\n"
altri simboli		.
\end{lstlisting}


\textbf{Funzioni built-in}
\begin{lstlisting}[breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}]
print		"print" 
quit		"quit"
connect		"connect"
disconnect	"disconnect"
receive		"receive"
send		"send"
insert		"insert"
remove		"remove"
length		"length"
s2i		"s2i"
s2r		"s2r"
s2d		"s2d"
s2a		"s2a"	
s2l		"s2l"
toString	"toString"
console		"console"
strip		"strip"
split		"split"
sleep		"sleep"
typeof		"typeof"
isConnected	"isConnected"
include		^"#"[ \t]*include[ \t]*[\"].*[\"]
debug		"debug"[0-9]+
\end{lstlisting}

\textbf{Selettori}
\begin{lstlisting}[breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}]
.port		".port"
.address	".address"
\end{lstlisting}

\textbf{Strutture di controllo}
\begin{lstlisting}[breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}]
if	"if"
else	"else
while	"while"
for	"for"
in	"in"
def	"def"
\end{lstlisting}

Per riuscire a scrivere qualsiasi simbolo all'interno delle stringhe, vengono utilizzati gli \texttt{state} di Flex. Le costanti \texttt{TRUE} e \texttt{FALSE} corrispondono semplicemente a 1 e 0, mentre \texttt{NL} rappresenta il carattere di ritorno a capo

	%% FUNZIONALITÀ DEL LINGUAGGIO
\subsection{Funzionalità del linguaggio}\label{subsection:fun}
In PASTEL è presente un'ampia gamma di funzioni che possono essere utilizzate per gestire le connessioni dei devices, manipolare i dati ed eseguire funzioni di sistema. Vengono di seguito elencate e descritte tutte le funzioni. Per indicare il numero di argomenti richiesti da ogni funzione, viene adoperata una notazione Prolog-like.
\begin{itemize}
\item \texttt{console/1} effettua una chiamata di sistema per aprire una finestra di terminale su cui viene eseguito il programma \texttt{netcat} in modalità server, in ascolto sulla porta del device specificato come argomento. Lo scopo di questa funzione è facilitare le operazioni di testing, permettendo di simulare il comportamento di un dispositivo fisico; un altro possibile impiego è consentire all'utente l'inserimento di dati in maniera interattiva. Questa funzione è parametrizzata in base al sistema operativo (Linux o macOS) poiché i due sistemi operativi usano diverse convenzioni. In altri sistemi operativi questa funzione non è supportata.
\item \texttt{connect/1} attiva una connessione TCP verso il \texttt{device} passato come parametro. Se il tentativo di connessione ha successo, una chiamata a \texttt{isConnected/1} sullo stesso device restituirà un valore diverso da 0 (TRUE), in caso contrario verrà stampato un messaggio di errore sullo standard error, e chiamate a \texttt{isConnected/1} restituiranno FALSE.
\item \texttt{disconnect/1} termina la connessione TCP precedentemente creata verso il \texttt{device} passato come parametro. Se non c'è una connessione attiva verso il device, verrà stampato un messaggio di errore sullo standard error.
\item \texttt{receive/1} tenta di ricevere una stringa dal device passato come parametro e restituendola come valore di ritorno. Se non è presente una connessione attiva verso il device, verrà stampato un messaggio di errore sullo standard error. 
\item \texttt{send/2} manda al \texttt{device} passato come primo parametro della funzione e verso cui è già attiva una connessione TCP, la stringa passata come secondo parametro
\item \texttt{isConnected/1} restituisce un valore non nullo se c'è una connessione attiva verso il \texttt{device} passato come parametro, altrimenti restituisce \texttt{0}
\item \texttt{length/1} restituisce un valore di tipo \texttt{int} che rappresenta il numero degli elementi contenuti nella lista passata alla funzione come parametro.
\item \texttt{insert/3} inserisce nella lista passata come primo parametro l'elemento contenuto nel secondo parametro, nella posizione specificata dal terzo parametro. Quindi se si vuole fare un inserimento in testa, basta usare \texttt{insert(nome\_lista, elemento, 0)}, per aggiungere in coda invece si può sfruttare la funzione \texttt{length} e quindi usare \texttt{insert(nome\_lista, elemento, length(nome\_lista))}. 
Se, data una lista \texttt{l}, \texttt{length(l)=N1} e viene eseguita \texttt{insert(l,x,N2)} con \texttt{N2>N1}, verrà stampato un messaggio di errore sullo standard error, non essendo consentiti elementi di una lista non inizializzati.
\item \texttt{remove/2} rimuove dalla lista passata come primo parametro, l'elemento nella posizione specificata dal secondo parametro. Se si vuole eliminare il primo elemento della lista si può usare \texttt{remove(nome\_lista, 0)}, se si vuole eliminare l'ultimo si può ricorrere alla funzione \texttt{length} e quindi usare \texttt{remove(nome\_lista, length(nome\_lista)-1)}. Tentare di rimuovere un elemento in una posizione negativa, o oltre la fine della lista, comporta un messaggio di errore.\\
Si noti che le funzioni \texttt{insert/3} e \texttt{remove/2} modificano direttamente la lista passata come primo argomento, non ne restituiscono una copia con le modifiche specificate, queste funzioni hanno quindi effetti collaterali ed è necessario prestare attenzione quando si adoperano.
\item \texttt{typeof/1} restituisce una stringa rappresentante il tipo del valore passato come parametro.
\item \texttt{s2i/1} restituisce un valore di tipo \texttt{int} a partire da un valore di tipo \texttt{string} passato come parametro. Stampa un messaggio di errore nel caso in cui la stringa non rappresenti un valore intero in base 10.
\item \texttt{s2r/1} restituisce un valore di tipo \texttt{real} a partire da un valore di tipo \texttt{string} passato come parametro. Stampa un messaggio di errore nel caso in cui la stringa non rappresenti un numero reale. 
\item \texttt{s2a/1} restituisce un valore di tipo \texttt{address} a partire da un valore di tipo \texttt{string} passato come parametro. Stampa un messaggio di errore nel caso in cui la stringa non rappresenti un indirizzo IP valido.  
\item \texttt{s2d/1} restituisce un valore di tipo \texttt{device} a partire da un valore di tipo \texttt{string} passato come parametro.
Se la stringa non rappresenta una combinazione valida di indirizzo IP e numero di porta separati dal simbolo \texttt{`:'} viene stampato un messaggio di errore.  
\item \texttt{s2l/1} restituisce un valore di tipo \texttt{list} a partire da un valore di tipo \texttt{string} passato come parametro. La lista restiuita conterrà i singoli caratteri che formano la stringa di input. Restituisce un errore nel caso in cui l'argomento di input non sia una stringa.\\
L'operazione inversa non è fornita come una funzione standard perché, come mostrato nella seguente implementazione \textit{naïve}, è nativamente implementabile in PASTEL:
\begin{verbatim}
  def join_chars(split_string){
    string joined_string = "";
    for(char in split_string){ joined_string = joined_string + char; }
    joined_string;
  }
\end{verbatim}
\item \texttt{toString/1} restituisce un valore di tipo \texttt{string} a partire da un parametro di un qualsiasi tipo. Nella conversione di una lista in stringa, viene restituita una stringa formata dall'elenco degli elementi che fanno parte della lista separati da virgole e racchiusi da parentesi quadre, ovvero ``\texttt{[ el\_1 , el\_2 , ... , el\_n ]}''.
\item \texttt{strip/1} restituisce una stringa ottenuta da quella passata come parametro rimuovendo i caratteri di carriage return, line feed, tabulazioni, e spazi a inizio e fine stringa.
\item \texttt{split/2} restituisce un valore di tipo \texttt{list}, contenente tutte le sottostringhe della stringa passata come primo parametro ottenute considerando come divisore dei campi la stringa passata come secondo parametro.
\item \texttt{print/1} stampa a schermo il risultato della funzione \texttt{toString} del parametro, seguito da un ritorno a capo.
\item \texttt{sleep/1} effettua una chiamata di sistema per sospendere il processo per il numero di secondi passato come parametro.
\item \texttt{quit/1} effettua una chiamata di sistema per terminare l'esecuzione dell'interprete. Il parametro, se di tipo \texttt{int}, serve per specificare un valore di ritorno del programma o, se di tipo \texttt{string}, per stampare una stringa a fine esecuzione.
\end{itemize}

Il linguaggio è inoltre fornito di una modalità \texttt{debug}, attivabile scrivendo \texttt{debug} seguito da un numero diverso da 0 e disattivabile con \texttt{debug0}. Questa modalità consente di stampare a schermo una rappresentazione testuale dell'albero sintattico generato in fase di parsing dopo l'esecuzione delle operazioni. \\
Un'altra importante funzionalità è la direttiva di inclusione, che fornisce uno strumento fondamentale per la programmazione in grande.


	%% CASI D'USO
\subsection{Casi d'uso}\label{subsection:casi-d_uso}
Per verificare l'applicabilità del linguaggio nel contesto target sono state effettuate delle simulazioni di potenziali ambiti in cui PASTEL potrebbe essere adoperato. Poiché il linguaggio presenta numerose funzionalità e permette lo sviluppo di software anche molto complesso, non essendo possibile esplorare tutte le possibilità offerte da PASTEL in modo conciso, ai fini di questa trattazione è stato scelto di mostrare un sottoinsieme delle funzionalità ritenuto particolarmente rappresentativo.

		%% NETWORK DISCOVERY
\subsubsection{Network discovery}\label{subsubsection:net-disc}
In una rete di sensori generalmente è necessario che ogni nodo sappia quali sono i suoi vicini e come raggiungerli, a questo scopo sono stati sviluppati un grande numero di protocolli~\cite{narten1998neighbor, kandhalu2010u, alsa2012secure}.

In questo caso d'uso mostriamo come, con un codice relativamente compatto, a partire dalla conoscenza dell'indirizzo di un singolo nodo indicato con \texttt{root}, sia possibile ricostruire la topologia della porzione di rete connessa al nodo \texttt{root}.\\
Nel codice mostrato in~\ref{listing:net-disc} ogni nodo viene interrogato per ottenere la lista dei suoi vicini tramite la procedura \texttt{find\_neighbours}. Tutti i vicini del nodo che non sono già stati individuati precedentemente vengono aggiunti ad una lista di nodi noti.

Ogni nodo comunica la lista dei suoi vicini restituiendo in formato testuale indirizzo IP e numero di porta ai quali sono raggiungibili, separando i vari nodi con delle virgole. Il linguaggio PASTEL mette a disposizione funzioni bultin che permettono in modo estremamente semplice, a partire dai dati forniti in questo formato, di ottenere una lista PASTEL e convertire tutte le stringhe in device utilizzabili all'interno del programma.

L'algoritmo termina automaticamente nonappena l'ultimo dei nodi noti interrogato non restituisce nodi nuovi, a quel punto si saranno individuati tutti i nodi raggiungibili a partire da \texttt{root}.

Per semplicità si assume che il calcolatore che esegue il programma abbia un range di comunicazione molto superiore ai nodi della rete, e che possa quindi raggiungerli in un singolo hop, una strategia più generale dovrebbe ovviamente prevedere la costruzione di messaggi di routing.

\lstinputlisting[firstline=3, lastline=41, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Sorgente network\_discovery.pa}, label={listing:net-disc}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]{../testfiles/network_discovery.pa}

		%% PUBLISH-SUBSCRIBE
\subsubsection{Publish-Subscribe}\label{subsubsection:pub-sub}

Come visto precedentemente in~\cite{tandale2017empirical} il modello Publish-Subscribe è molto comune come protocollo di comunicazione nel campo IoT. Nel listato~\ref{listing:sub} mostriamo come PASTEL permetta con facilità di interrogare una lista di nodi per ottenere i topic a cui ogni nodo intende fare il subscribe, dopo questo step di configurazione è immediato poter mandare a tutti i nodi iscritti ad un topic un determinato messaggio.


\lstinputlisting[firstline=1, lastline=62, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Sorgente subscriber.pa}, label={listing:sub}, breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}
 ]{../testfiles/subscriber.pa}


Con questo framework diventa estremamente facile per un nodo comunicare un messaggio da mandare a tutti i nodi iscritti ad un topic, come mostrato nel listato~\ref{listing:pub}.

Il programma si aspetta un input del tipo ``\texttt{<lista di topic> :TOPICS <messaggio>}'', la parte di messaggio che precede ``\texttt{:TOPICS}'' è interpretata come una lista di topic separati da virgole, il messaggio che segue quel tag, invece, verrà inviato a tutti i nodi che si sono precedentemente iscritti ad almeno uno di quei topic.

\lstinputlisting[firstline=1, lastline=29, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Sorgente publisher.pa}, label={listing:pub}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/publisher.pa}

Lo schema di funzionamento illustrato può ovviamente essere ulteriormente raffinato impedendo l'iscrizione multipla ad uno stesso topic e aggiungendo controlli per evitare di inviare più volte uno stesso messaggio un nodo iscritto a più topic, o al nodo che ha originato il messaggio. Inoltre è possibile prevedere la possibilità di cancellare le iscrizioni o modificarle periodicamente.

	%% RISULTATI OTTENUTI
\subsection{Risultati ottenuti}\label{subsection:risultati}

Il codice mostrato nelle sezioni~\ref{subsubsection:net-disc} e~\ref{subsubsection:pub-sub} mostra la potenzialità di essere integrato in un unico sistema software che, inserito in una rete, a partire dalla conoscenza di un singolo nodo, riesce a ricostruire la topologia della rete raggiungibile e gestire il funzionamento di un protocollo non banale del tipo publish-subscribe, dimostrando l'applicabilità del linguaggio proposto all'interno del contesto target. 

Per testare la scalabilità dell'implementazione del linguaggio abbiamo misurato il tempo impiegato per inviare un numero crescente di messaggi.\\
Un invio di messaggio si riassume nelle seguenti operazioni:
\begin{enumerate}
	\item Si stabilisce una connessione.
	\item{Si verifica che la connessione abbia avuto successo.}
	\item Si invia il messaggio. 
	\item Si richiude la connessione.
\end{enumerate}

Al fine di ottenere risultati il più possibile realistici abbiamo usato tre schemi diversi con cui mandare i messaggi:
\begin{itemize}
	\item Ciclo iterativo: all'interno di un ciclo while vengono eseguite le operazioni sopra citate.
	\item Chiamate a funzione: all'interno di un ciclo while viene chiamata una funzione che effettua le operazioni di invio.
	\item Funzione ricorsiva: una funzione ha un parametro che conta quanti messaggi devono ancora essere inviati. Al termine dell'invio di un messaggio il parametro viene decrementato e si effettua una chiamata ricorsiva.
\end{itemize}

Il tempo impiegato è misurato utilizzando il programma di sistema \texttt{time}~\cite{time1linux}. Il tempo totale corrisponde al valore ``real'', mentre il tempo netto è la somma di ``user'' e ``sys''. I programmi eseguono una chiamata a \texttt{console()} che comporta un secondo di attesa per l'apertura del terminale.

\begin{table}[htbp]
	\centering
	\resizebox{\columnwidth}{!}{
	\begin{tabular}{|c| cc | cc| cc|}
		\hline
		                   & \multicolumn{2}{c|}{{\normalsize Ciclo iterativo }} & \multicolumn{2}{c|}{{\normalsize Chiamate a funzione }} & \multicolumn{2}{c|}{{\normalsize Ricorsione }} \\ \cline{2-7}
		Numero di messaggi & Tempo totale (s) &         Tempo netto (s)          & Tempo totale (s) &           Tempo netto (s)            & Tempo totale (s) &       Tempo netto (s)       \\ \hline
		        10         & 1.563            &              0.479               & 1.531            &                0.461                 & 3.168            &            0.099            \\
		        50         & 2.629            &              0.517               & 1.554            &                0.484                 & 3.166            &            0.102            \\
		       100         & 1.539            &              0.467               & 1.654            &                0.495                 & 5.192            &            0.104            \\
		       1000        & 2.659            &              0.544               & 1.726            &                0.581                 & 1.264            &            0.247            \\
		      10000        & 47.178           &              1.278               & 5.542            &                1.428                 & 18.718           &           13.194            \\ \hline
	\end{tabular}}
	\caption{Tempo necessario per l'invio di un numero crescente di messaggi}
	\label{table:performance}
\end{table}

Come si può vedere dalla tabella~\ref{table:performance} e in figura~\ref{fig:performance-graph} (si noti che gli assi sono in scala logaritmica), l'implementazione con la chiamata a funzione è quella mediamente più veloce, anche se ha un tempo netto leggermente maggiore dell'implementazione puramente ricorsiva, anche se resta comparabile.

\begin{figure}
	\centering
	\resizebox{0.8\columnwidth}{!}{
		\includegraphics{sources/performance-graph}}
	\caption{Performance dell'interprete}
	\label{fig:performance-graph}
\end{figure}

Una possibile spiegazione per questa peculiarità è che l'invio di messaggi è un processo molto IO-bound, quindi l'approccio iterativo è sufficientemente veloce da non trovare le risorse disponibili e viene sospeso aspettando un interrupt dal sistema operativo, incorrendo in numerosi context switch costosi. La chiamata a funzione, invece, ha dell'overhead per la creazione dello stack, questo, come si vede dal tempo netto, è abbastanza piccolo, ma potrebbe essere sufficientemente grande da evitare il context switch.

Questo dato sembra anche giustificare la scelta di sviluppare un linguaggio di scripting interpretato invece che un linguaggio compilato, visto che l'ambito di applicazione principale sarà legato all'invio di messaggi nella rete, e non elaborate manipolazioni dei dati.

Il tempo totale dell'implementazione ricorsiva è il maggiore di tutti\footnote{Su 10000 messaggi l'esecuzione del programma ricorsivo è stata interrotta prematuramente dall'esaurimento della memoria a disposizione}, nonostante il numero di scope da creare sia lo stesso delle chiamate a funzione iterative, infatti, le ricerche dei simboli nello stack delle chiamate a funzione diventano progressivamente più costose all'aumento delle chiamate ricorsive.

\begin{table}[htbp]
	\centering
    \resizebox{\columnwidth}{!}{
	\begin{tabular}{|c| cc | cc| cc|}
		\hline
		                   & \multicolumn{2}{c|}{{\normalsize PASTEL }} & \multicolumn{2}{c|}{{\normalsize Python singola connessione }} & \multicolumn{2}{c|}{{\normalsize Python connessioni multiple}} \\ \cline{2-7}
		Numero di messaggi & Tempo totale (s) &     Tempo netto (s)     & Tempo totale (s) &               Tempo netto (s)               & Tempo totale (s) &               Tempo netto (s)               \\ \hline
		        10         & 1.350            &          0.17           & 1.339            &                    0.32                     & 1.357& 0.340\\
		        50         & 1.278            &          0.15           & 1.328            &                    0.31                     & 1.448 &0.430\\
		       100         & 1.260            &          0.15           & 1.441            &                    0.42                     &  1.610&0.570\\
		       1000        & 1.305            &          0.19           & 1.340            &                    0.33                     & 6.232 &4.800\\
		      10000        & 1.508            &          0.35           & 2.115            &                    0.56                     & 10.254 &8.54\\ \hline
	\end{tabular}}
	\caption{Tempo necessario per l'invio di un numero crescente di messaggi in Python, e in PASTEL con connessione singola}
	\label{table:python-performance}
\end{table}

Per potere meglio valutare le performance del linguaggio, è stato deciso di confrontare le prestazioni sullo stesso benchmark con il Python. È stata scelta la modalità ``chiamata a funzione'', inoltre lo stesso test è stato ripetuto anche con l'invio di più messaggi una singola connessione per valutare una più ampia gamma di scenari. I nuovi risultati sperimentali sono sintetizzati nella tabella~\ref{table:python-performance}.

Come si può notare anche dalla figura~\ref{fig:performance-comparison}, il programma PASTEL ha sempre prestazioni comparabili se non migliori di quelle del programma equivalente in Python, a testimonianza della validità dell'implementazione.

Tutto il codice utilizzato per i benchmarking è riportato nell'appendice.



\begin{figure}
	\centering
	\resizebox{\columnwidth}{!}{
		\includegraphics{sources/pvp.pdf}}
	\caption{Confronto delle performance di PASTEL e Python}
	\label{fig:performance-comparison}
\end{figure}


%% CONCLUSIONI

\section{Conclusioni}\label{section:conclusioni}

La progettazione del linguaggio PASTEL ha permesso di affrontare le tematiche trattate nel corso di \textit{Linguaggi e traduttori} e di applicare molti dei concetti teorici discussi durante le lezioni. Nonostante i tempi di sviluppo ridotti, i test effettuati mostrano performance soddisfacenti.
Gli strumenti Flex e Bison hanno agevolato la realizzazione di un linguaggio relativamente complesso e completo, riducendo la mole di codice da dovere sviluppare.
Visti i tempi di realizzazione limitati, PASTEL non possiede tutte le funzionalità che ci si aspetta da un linguaggio di programmazione general purpose, e sono presenti molte direzioni verso cui si potrebbe potenziare il linguaggio. In conclusione segue una breve disamina di alcune features che potrebbero arricchire il linguaggio. 
\begin{itemize}
	\item Lettura e scrittura da file, per consentire ad esempio la scrittura di log dei device 
	\item Al momento per potere effettuare interazioni con l'utente, quando un programma viene eseguito leggendolo da un file, è necessario ricorrere a \texttt{console}. Sarebbe certamente più agevole consentire l'utilizzo dello standard input.
	\item PASTEL non è utilizzabile su sistemi operativi Windows perché, interfacciarsi alle socket, Windows utilizza un'API differente da Linux e macOS. Un linguaggio maturo dovrebbe avere implementazioni per tutti i maggiori sistemi operativi.
	\item Gli indirizzi gestiti sono solo quelli IPv4, potrebbe essere aggiunto il supporto al protocollo IPv6.
	\item Le chiamate a \texttt{receive} sono letture bloccanti. Un dispositivo malfunzionante però potrebbe non rispondere mai ai messaggi inviati, fermando l'esecuzione del programma. Per permettere la scrittura di programmi più robusti si potrebbe introdurre letture da socket non bloccanti~\cite{hall2001beej} specificando un timeout.
	\item Nell'ambito IoT, oltre al TCP, esistono molti protocolli per il trasporto affidabile dei dati basati su UDP~\cite{masirap2016evaluation}, supportare anche UDP quindi renderebbe il linguaggio più flessibile e potente.
\end{itemize}

%% BIBLIOGRAFIA
\clearpage
\bibliographystyle{unsrt}
\bibliography{tesina}
\addcontentsline{toc}{section}{Riferimenti bibliografici}


%% APPENDICE

\section*{Appendice}\label{section:appendix}
\addcontentsline{toc}{section}{Appendice}

\begin{center}[b]
	\centering
	\resizebox{\columnwidth}{!}{
		\includegraphics{sources/parser}}\\
	Grafico del FSA generato utilizzando GNU Bison 3.5.4 XML Automaton Report. L'immagine è in formato vettoriale, quindi è possibile ingrandire a piacere.
\end{center}

\clearpage

\lstinputlisting[frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Codice per inviare messagi su connessioni separate in un loop.}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/benchmarks/send_messages_loop.pa}

\lstinputlisting[frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Codice per inviare messagi su connessioni separate con chiamate a funzione in un loop.}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/benchmarks/send_messages_func.pa}

\lstinputlisting[frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Codice per inviare messagi su connessioni separate ricorsivamente.}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/benchmarks/send_messages_recur.pa}

\lstinputlisting[frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Codice Python per inviare messagi su connessioni separate con chiamate a funzione in un loop.}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/benchmarks/send_multiple.py}

\lstinputlisting[frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Codice PASTEL per inviare messagi su una singola connessione con chiamate a funzione in un loop.}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/benchmarks/send_single.pa}

\lstinputlisting[frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Codice Python per inviare messagi su una singola connessione con chiamate a funzione in un loop.}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/benchmarks/send_single.py}

\end{document}          

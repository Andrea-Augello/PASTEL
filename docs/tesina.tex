% !TeX spellcheck = it_IT
\documentclass[10pt]{article}
\usepackage{color, soul}
\newcommand{\hlc}[2][yellow]{ {\sethlcolor{#1} \hl{#2}} }
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[italian]{babel}


% Title Page
\title{PASTEL}
\author{{Augello Andrea} \and {Bafumo Francesco} \and{La Martina Marco}}


\begin{document}
\maketitle
\tableofcontents
\clearpage


%% INTRODUZIONE

\section{Introduzione}
PASTEL è stato pensato come un linguaggio di scripting per gestire e coordinare le interazioni tra dispositivi IoT basati su TCP.\\
L'utilizzo di PASTEL può essere vantaggioso in sistemi ciberfisici complessi che necessitano una conoscenza dello stato globale del sistema per coordinarsi. Infatti il sistema potrebbe includere dispositivi con risorse limitate e scarse capacità computazionali, che quindi non sono in grado di memorizzare lo stato del resto dei sensori ed effettuare decisioni complesse. 

Un altro contesto in cui PASTEL può essere utile è testare in modo replicabile il corretto comportamento interattivo di un sistema ciberfisico: il linguaggio proposto infatti può facilmente simulare l'output di molti sensori ed inviarlo agli attuatori.

Il resto della relazione è strutturato come segue: la sezione~\ref{section:stato-arte} illustra il contesto in cui si colloca il linguaggio proposto, nella sezione~\ref{section:descrizione} vengono analizzati i dettagli implementativi, nella sezione~\ref{section:caratteristiche-linguaggio} si illustrano le caratteristiche di PASTEL e degli esempi di applicazioni, infine nella sezione~\ref{section:conclusioni} vengono riepilogati i punti principali del lavoro svolto.


%% STATO DELL'ARTE

\section{Stato dell'arte}\label{section:stato-arte}

I dispositivi IoT comunemente eseguono protocolli semplici come CoAP, REST e MQTT~\cite{tandale2017empirical}. 

Constrained Application Protocol (CoAP) è un   protocollo di trasferimento web specializzato da utilizzare con nodi o reti con risorse limitate (ad es. reti a bassa potenza, senza trasferimento affidabile dei dati). I nodi hanno spesso microcontrollori  a 8 bit con piccole quantità di ROM e RAM, mentre reti con risorse limitate come IPv6 su Low-Power Wireless Personal Area  (6LoWPANs) hanno spesso elevati tassi di errore dei pacchetti e un tipico throughput di 10 s di kbit/s. Il protocollo è progettato per applicazioni  machine-to-machine (M2M) come smart energy e building automation.~\cite{shelby2014constrained}.

Representational State Transfer (REST) è uno tipo di architettura per i sistemi distribuiti. L'espressione representational state transfer e il suo acronimo, REST, furono introdotti nel 2000 nella tesi di dottorato di Roy Fielding, uno dei principali autori delle specifiche dell'Hypertext Transfer Protocol (HTTP), e vennero rapidamente adottati dalla comunità di sviluppatori Internet.
Il termine REST rappresenta un sistema di trasmissione di dati su HTTP senza ulteriori livelli, quali ad esempio SOAP. I sistemi REST non prevedono il concetto di sessione, ovvero sono stateless.
L'architettura REST si basa su HTTP. Il funzionamento prevede una struttura degli URL ben definita che identifica univocamente una risorsa o un insieme di risorse e l'utilizzo dei verbi HTTP specifici per il recupero di informazioni (GET), per la modifica (POST, PUT, PATCH, DELETE) e per altri scopi (OPTIONS, ecc.)~\cite{fielding2000architectural}.

MQTT è un protocollo di connettività machine-to-machine (M2M) / "Internet of Things". È stato progettato come un trasporto di messaggistica estremamente leggero. È utile per le connessioni  remote in cui è richiesto un codice ridotto e/o l'ampiezza di banda della rete è limitata. Ad esempio, è stato utilizzato nei sensori che comunicano con un intermediario tramite collegamento satellitare, attraverso occasionali connessioni dial-up con operatori sanitari e in una gamma di scenari di automazione domestica e piccoli dispositivi. È ideale anche per le applicazioni mobili a causa delle sue dimensioni ridotte, basso consumo energetico, pacchetti di dati ridotti al minimo e distribuzione efficiente delle informazioni a uno o più ricevitori~\cite{banks2019mqtt}.\\\\



Il linguaggio proposto può facilmente essere utilizzato con il protocollo REST essendo basato su HTTP, un protocollo di livello applicazione che utilizza solo testo. CoAP, utilizzando UDP come protocollo di livello trasporto, non è compatibile con l'ambiente PASTEL. MQTT si appoggia al TCP, tuttavia è basato sull'invio di codice binario, quindi non è direttamente implementabile in PASTEL a meno di utilizzare particolari tecniche di encoding~\cite{josefsson2006base16}, in quel caso sarebbe certamente possibile, ma non è il tipo di applicazione verso cui è orientato il linguaggio.

L'ambiente target principale è quello dei dispositivi in grado di eseguire codice simbolico~\cite{gaglio2017dc4cd}. L'utilizzo di codice simbolico (e.g. in dispositivi che eseguono un interprete FORTH~\cite{brodie2004thinking}) permette di generare in modo automatico istruzioni valide per tutti i dispositivi presi in considerazione, indipendentemente dall'architettura hardware sottostante.
Inoltre, essendo possibile definire nuove parole su nodi già installati ( utilizzando quelle precedentemente definite) è possibile, a partire da delle primitive legate alle trasmissioni, abilitare tutti i nodi della rete all'esecuzione di protocolli arbitrari in una fase di inizializzazione in cui viene comunicato il codice simbolico necessario. 

Con un approccio simbolico diventa anche possibile supportare protocolli normalmente basati su bytecode come MQTT nativamente~\cite{gaglio19interoperable}.
Essendo questo il campo di applicazione principale, su questo si incentreranno di casi d'uso nella sezione \ref{subsection:casi-d_uso}.\\\\



PASTEL può essere pensato come un linguaggio per generare programmi che possano mandare e ricevere messaggi testuali tramite TCP, condizionati e iterati facilmente. Questo concept può essere pensato come l'equivalente di \texttt{expect}~\cite{libes1991expect, libes1990expect, libes1995exploring} per reti di sensori wireless (WSN).

Expect è un programma che "parla" con altri programmi interattivi secondo uno script. Seguendo lo script, Expect sa cosa ci si può aspettare da un programma e quale dovrebbe essere la risposta corretta. Un linguaggio interpretato fornisce ramificazioni e strutture di controllo di alto livello per dirigere il dialogo. Inoltre, l'utente può assumere il controllo e interagire direttamente quando lo desidera, in seguito restituendo il controllo allo script.

Il tool \texttt{expect} è basato sul linguaggio Tcl. Tcl fornisce il controllo per il flusso (ad esempio, if, for, break), la valutazione delle espressioni e diverse altre funzioni come la ricorsione, definizione delle procedure, ecc.. 

Tcl è stato uno dei primi linguaggi "dinamici" a diventare popolare, vedendo un uso diffuso a partire dai primi anni '90. Tcl ha trovato ampio successo in molti campi, e le distribuzioni di Tcl spaziano da dispositivi integrati come router, a infrastrutture di back-end distribuite.~\cite{nadkarni2017tcl}.\\\\

Alla luce di quanto detto, con questo linguaggio ci prefiggiamo l'obiettivo di fornire uno strumento che permette di interfacciarsi con facilità e in modo affidabile con dispositivi IoT, con la possibilità di potere iterare le operazioni, manipolare i dati con estrema facilità e definire delle routine da potere effettuare in maniera condizionata.


%% DESCRIZIONE DEL PROGETTO

\section{Descrizione del progetto}\label{section:descrizione}

 	%% ANALISI DEI REQUISITI
\subsection{Analisi dei requisiti}

	%% SCELTE PROGETTUALI
\subsection{Scelte progettuali}

\begin{itemize}
	\item Lookup dei simboli eval invece che lexer come il libro~\cite{levine2009flex}
	\item Stringhe immutabili, singolo carattere non direttamente accessibile
	\item Possibilità di dividerle in lista di "caratteri" (stringhe lugnghezza 1)
	\item Passaggio di valori per copia
	\item Scoping statico
	\item Cicli condividono scope
	\item Campi di device accessibili ma non modificabili, evita modifiche a connessioni aperte.
	\item Liste eterogenee puntatore a next
	\item Foreach
	\item Include a tempo di lexer, impedisce include condizionali che generano codice potenzialmente ambiguo con comportamento imprevedibile.
	\item Interprete invece che compilatore
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
	\item 
\end{itemize}
%% CARATTERISTICHE DEL LINGUAGGIO

\section{Caratteristiche del linguaggio}\label{section:caratteristiche-linguaggio}

	%% GRAMMATICA
\subsection{Grammatica}

	%% DESCRIZIONE DEL PARSER
\subsection{Descrizione del parser}
{[...]} Parser di tipo LALR[...] parsing bottom-up, quindi è possibile gestire le produzioni con ricorsione a sinistra [...] utilizzando Bison per generare il parser e Flex per riconoscere i token nella fase di lexing~\cite{levine2009flex}

Le regole di produzione in formato BNF[...]:

\begin{lstlisting}
<program>::= 
	| <program> <stmt>
	| <program> DEF NAME '(' <symlist> ')' '{' <list> '}'  

<stmt>::= IF '(' <exp> ')' '{' <list> '}' 
	| IF '(' <exp> ')' '{' <list> '}' ELSE '{' <list> '}'  
	| WHILE '(' <exp> ')' '{' <list> '}'    
	| FOR '(' NAME IN <exp> ')' '{' <list> '}'  
	| <exp> ';'
	| <decl> ';'

<list>::=
	| stmt <list> 

<exp>::= '(' <exp> ')'         
	| FUNC '(' <explist> ')' 
	| VALUE              
	| <exp> ':' <exp>         
	| <exp> '+' <exp>         
	| <exp> '-' <exp>         
	| <exp> '*' <exp>          
	| <exp> '/' <exp>          
	| <exp> AND <exp>          
	| <exp> OR <exp>           
	| '-' <exp>
	| NAME'[' <exp> ']'          
	| NAME                 
	| <exp> CMP <exp>          
	| <exp> ADDR             
	| <exp> PORT             
	| NAME '(' explist ')' 

<decl>::= TYPE NAME          
	| NAME '=' <exp>                    
	| NAME '[' <exp> ']' '=' <exp>
	| TYPE NAME '=' <exp>     

<explist>::=
	| <exp>
	| <exp> ',' <explist> 

<symlist>::= 
	| NAME       
	| NAME ',' <symlist>
\end{lstlisting}

Le regole di produzione per \texttt{<exp>} sembrerebbero ambigue, infatti una stessa sequenza di operatori potrebbe essere rappresentata da più alberi di parsing. È generalmente possibile riscrivere la grammatica per eliminare l'ambiguità, però Bison mette a disposizione degli strumenti che permettono di specificare la precedenza degli operatori disambiguando la grammatica e scartando automaticamente gli alberi di parsing non validi, consentendo l'utilizzo di una grammatica più semplice e compatta.

In figura~\ref{fig:parser_simple} viene riportato l'automa a stati finiti generato da Bison su una versione ridotta della grammatica per fornire un'idea generale della struttura di un programma grammaticalmente corretto. Questa grammatica semplificata rimuove delle regole di produzione ricorsive per ridurre il numero di stati, migliorando la leggibilità. In appendice si riporta il grafo della grammatica completa.


\begin{figure}
	\centering
	\resizebox{\columnwidth}{!}{
	\includegraphics{sources/parser_simple}}
	\caption{Grafo del FSA generato utilizzando  GNU Bison 3.5.4 XML Automaton Report su una struttura fortemente semplificata per facilitare la rappresentazione. La grammatica completa non presenta conflitti shift/reduce e reduce/reduce.}
	\label{fig:parser_simple}
\end{figure}

	%% CASI D'USO
\subsection{Casi d'uso}\label{subsection:casi-d_uso}
Per verificare l'applicabilità del linguaggio nel contesto target sono state effettuate delle simulazioni di potenziali ambiti in cui PASTEL potrebbe essere adoperato. Poiché il linguaggio presenta numerose funzionalità e permette lo sviluppo di software anche molto complesso, non essendo possibile esplorare tutte le possibilità offerte da PASTEL in modo conciso, ai fini di questa trattazione è stato scelto di mostrare un sottoinsieme delle funzionalità ritenuto particolarmente rappresentativo.

		%% NETWORK DISCOVERY
\subsubsection{Network discovery}\label{subsubsection:net-disc}
In una rete di sensori generalmente è necessario che ogni nodo sappia quali sono i suoi vicini e come raggiungerli, a questo scopo sono stati sviluppati un grande numero di protocolli~\cite{narten1998neighbor, kandhalu2010u, alsa2012secure}.

In questo caso d'uso mostriamo come, con un codice relativamente compatto, a partire dalla conoscienza dell'indirizzo di un singolo nodo indicato con \texttt{root}, sia possibile ricostruire la topologia della porzione di rete connessa al nodo \texttt{root}.\\
Nel codice mostrato in~\ref{listing:net-disc} ogni nodo viene interrogato per ottenere la lista dei suoi vicini tramite la procedura \texttt{find\_neighbours}. Tutti i vicini del nodo che non sono già stati individuati precedentemente vengono aggiunti ad una lista di nodi noti.

Ogni nodo comunica la lista dei suoi vicini restituiendo in formato testuale indirizzo IP e numero di porta ai quali sono raggiungibili, separando i vari nodi con delle virgole. Il linguaggio PASTEL mette a disposizione funzioni bultin che permettono in modo estremamente semplice, a partire dai dati forniti in questo formato, di ottenere una lista PASTEL e convertire tutte le stringhe in device utilizzabili all'interno del programma.

L'algoritmo termina automaticamente nonappena l'ultimo dei nodi noti interrogato non restituisce nodi nuovi, a quel punto si saranno individuati tutti i nodi raggiungibili a partire da \texttt{root}.

Per semplicità si assume che il calcolatore che esegue il programma abbia un range di comunicazione molto superiore ai nodi della rete, e che possa quindi raggiungerli in un singolo hop, una strategia più generale dovrebbe ovviamente prevedere la costruzione di messaggi di routing.

\lstinputlisting[firstline=3, lastline=41, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Sorgente di \lstname}, label={listing:net-disc}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]{../testfiles/network_discovery.pa}

		%% PUBLISH-SUBSCRIBE
\subsubsection{Publish-Subscribe}\label{subsubsection:pub-sub}

Come visto precedentemente in~\cite{tandale2017empirical} il modello Publish-Subscribe è molto comune come protocollo di comunicazione nel campo IoT. Nel listato~\ref{listing:sub} mostriamo come PASTEL permetta con facilità di interrogare una lista di nodi per ottenere i topic a cui ogni nodo intende fare il subscribe, dopo questo step di configurazione è immediato poter mandare a tutti i nodi iscritti ad un topic un determinato messaggio.


\lstinputlisting[firstline=1, lastline=62, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Sorgente di \lstname}, label={listing:sub}, breaklines=true, postbreak=\mbox{{$\hookrightarrow$}\space}
 ]{../testfiles/subscriber.pa}


Con questo framework diventa estremamente facile per un nodo comunicare un messaggio da mandare a tutti i nodi iscritti ad un topic, come mostrato nel listato~\ref{listing:pub}.

Il programma si aspetta un input del tipo ``\texttt{<lista di topic> :TOPICS <messaggio>}'', la parte di messaggio che precede ``\texttt{:TOPICS}'' è interpretata come una lista di topic separati da virgole, il messaggio che segue quel tag, invece, verrà inviato a tutti i nodi che si sono precedentemente iscritti ad almeno uno di quei topic.

\lstinputlisting[firstline=1, lastline=29, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Sorgente di \lstname}, label={listing:pub}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/publisher.pa}

Lo schema di funzionamento illustrato può ovviamente essere ulteriormente raffinato impedendo l'iscrizione multipla ad uno stesso topic e aggiungendo controlli per evitare di inviare più volte uno stesso messaggio un nodo iscritto a più topic, o al nodo che ha originato il messaggio. Inoltre è possibile prevedere la possibilità di cancellare le iscrizioni o modificarle periodicamente.

	%% RISULTATI OTTENUTI
\subsection{Risultati ottenuti}\label{subsection:risultati}

Il codice mostrato nelle sezioni~\ref{subsubsection:net-disc} e~\ref{subsubsection:pub-sub} mostra la potenzialità di essere integrato in un unico sistema software che, inserito in una rete, a partire dalla conoscenza di un singolo nodo, riesce a ricostruire la topologia della rete raggiungibile e gestire il funzionamento di un protocollo non banale del tipo publish-subscribe, dimostrando l'applicabilità del linguaggio proposto all'interno del contesto target. 

Per testare la scalabilità dell'implementazione del linguaggio abbiamo misurato il tempo impiegato per inviare un numero crescente di messaggi.\\
Un'invio di messaggio si riassume nelle seguenti operazioni:
\begin{enumerate}
	\item Si stabilisce una connessione.
	\item{Si verifica che la connessione abbia avuto successo.}
	\item Si invia il messaggio. 
	\item Si richiude la connessione.
\end{enumerate}

Al fine di ottenere risultati il più possibile realistici abbiamo usato tre schemi diversi con cui mandare i messaggi:
\begin{itemize}
	\item Ciclo iterativo: all'interno di un ciclo while vengono eseguite le operazioni sopra citate.
	\item Chiamate a funzione: all'interno di un ciclo while viene chiamata una funzione che effettua le operazioni di invio.
	\item Funzione ricorsiva: una funzione ha un parametro che conta quanti messaggi devono ancora essere inviati. Al termine dell'invio di un messaggio il parametro viene decrementato e si effettua una chiamata ricorsiva.
\end{itemize}

Il tempo impiegato è misurato utilizzando il programma di sistema \texttt{time}~\cite{time1linux}. Il tempo totale corrisponde al valore ``real'', mentre il tempo netto è la somma di ``user'' e ``sys''. I programmi eseguono una chiamata a \texttt{console()} che comporta un secondo di attesa per l'apertura del terminale.

\begin{table}[htbp]
	\centering
	\resizebox{\columnwidth}{!}{
	\begin{tabular}{|c| cc | cc| cc|}
		\hline
		                   & \multicolumn{2}{c|}{{\normalsize Ciclo iterativo }} & \multicolumn{2}{c|}{{\normalsize Chiamate a funzione }} & \multicolumn{2}{c|}{{\normalsize Ricorsione }} \\ \cline{2-7}
		Numero di messaggi & Tempo totale (s) &         Tempo netto (s)          & Tempo totale (s) &           Tempo netto (s)            & Tempo totale (s) &       Tempo netto (s)       \\ \hline
		        10         & 1.563            &              0.479               & 1.531            &                0.461                 & 3.168            &            0.099            \\
		        50         & 2.629            &              0.517               & 1.554            &                0.484                 & 3.166            &            0.102            \\
		       100         & 1.539            &              0.467               & 1.654            &                0.495                 & 5.192            &            0.104            \\
		       1000        & 2.659            &              0.544               & 1.726            &                0.581                 & 1.264            &            0.247            \\
		      10000        & 47.178           &              1.278               & 5.542            &                1.428                 & 18.718           &           13.194            \\ \hline
	\end{tabular}}
	\caption{Tempo necessario per l'invio di un numero crescente di messaggi}
	\label{table:performance}
\end{table}

Come si può vedere dalla tabella~\ref{table:performance} e in figura~\ref{fig:performance-graph} (si noti che gli assi sono in scala logaritmica), l'implementazione con la chiamata a funzione è quella con mediamente più veloce, anche se ha un tempo netto leggermente maggiore dell'implementazione puramente ricorsiva, anche se resta comparabile.

\begin{figure}
	\centering
	\resizebox{0.7\columnwidth}{!}{
		\includegraphics{sources/performance-graph}}
	\caption{Performance dell'interprete}
	\label{fig:performance-graph}
\end{figure}

Una possibile spiegazione per questa peculiarità è che l'invio di messaggi è un processo molto IO-bound, quindi l'approccio iterativo è sufficientemente veloce da non trovare le risorse disponibili e viene sospeso aspettando un interrupt dal sistema operativo, incorrendo in numerosi context switch costosi. La chiamata a funzione, invece, ha dell'overhead per la creazione dello stack, questo, come si vede dal tempo netto, è abbastanza piccolo, ma potrebbe essere sufficientemente grande da evitare il context switch.

Questo dato sembra anche giustificare la scelta di sviluppare un linguaggio di scripting interpretato invece che un linguaggio compilato, visto che l'ambito di applicazione principale sarà legato all'invio di messaggi nella rete, e non elaborate manipolazioni dei dati.

Il tempo totale dell'implementazione ricorsiva è il maggiore di tutti\footnote{Su 10000 messaggi l'esecuzione è stata interrotta prematuramente dall'esaurimento della memoria a disposizione}, nonostante il numero di scope da creare sia lo stesso delle chiamate a funzione iterative, infatti, le ricerche dei simboli nello stack delle chimate a funzione diventano progressivamente più costose all'aumento delle chiamate ricorsive.

\begin{table}[htbp]
	\centering
    \resizebox{\columnwidth}{!}{
	\begin{tabular}{|c| cc | cc| cc|}
		\hline
		                   & \multicolumn{2}{c|}{{\normalsize PASTEL }} & \multicolumn{2}{c|}{{\normalsize Python singola connessione }} & \multicolumn{2}{c|}{{\normalsize Python connessioni multiple}} \\ \cline{2-7}
		Numero di messaggi & Tempo totale (s) &     Tempo netto (s)     & Tempo totale (s) &               Tempo netto (s)               & Tempo totale (s) &               Tempo netto (s)               \\ \hline
		        10         & 1.350            &          0.17           & 1.339            &                    0.32                     & 1.357& 0.340\\
		        50         & 1.278            &          0.15           & 1.328            &                    0.31                     & 1.448 &0.430\\
		       100         & 1.260            &          0.15           & 1.441            &                    0.42                     &  1.610&0.570\\
		       1000        & 1.305            &          0.19           & 1.340            &                    0.33                     & 6.232 &4.800\\
		      10000        & 1.508            &          0.35           & 2.115            &                    0.56                     & 10.254 &8.54\\ \hline
	\end{tabular}}
	\caption{Tempo necessario per l'invio di un numero crescente di messaggi in Python, e in PASTEL con connessione singola}
	\label{table:python-performance}
\end{table}

Per potere meglio valutare le performance del linguaggio, è stato deciso di confrontare le prestazioni sullo stesso benchmark con il Python. È stata scelta la modalità ``chiamata a funzione'', inoltre lo stesso test è stato ripetuto anche con l'invio di più messaggi una singola connessione per valutare una più ampia gamma di scenari. I nuovi risultati sperimentali sono sintetizzati nella tabella~\ref{table:python-performance}.

Come si può notare anche dalla figura~\ref{fig:performance-comparison}, il programma PASTEL ha sempre prestazioni comparabili se non migliori di quelle del programma equivalente in Python, a testimonianza della validità dell'implementazione.

Tutto il codice utilizzato per i benchmarking è riportato nell'appendice.



\begin{figure}
	\centering
	\resizebox{0.7\columnwidth}{!}{
		\includegraphics{sources/pvp.pdf}}
	\caption{Confronto delle performance di PASTEL e Python}
	\label{fig:performance-comparison}
\end{figure}


%% CONCLUSIONI

\section{Conclusioni}\label{section:conclusioni}


%% BIBLIOGRAFIA

\clearpage
\bibliographystyle{unsrt}
\bibliography{references}
\addcontentsline{toc}{section}{Riferimenti bibliografici}

\clearpage


%% APPENDICE

\section*{Appendice}\label{section:appendix}
\addcontentsline{toc}{section}{Appendice}

\begin{center}
	\centering
	\resizebox{\columnwidth}{!}{
		\includegraphics{sources/parser}}\\
	Grafico del FSA generato utilizzando GNU Bison 3.5.4 XML Automaton Report.
\end{center}


\lstinputlisting[frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Codice per inviare messagi su connessioni separate in un loop.}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/benchmarks/send_messages_loop.pa}

\lstinputlisting[frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Codice per inviare messagi su connessioni separate con chiamate a funzione in un loop.}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/benchmarks/send_messages_func.pa}

\lstinputlisting[frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Codice per inviare messagi su connessioni separate ricorsivamente.}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/benchmarks/send_messages_recur.pa}

\lstinputlisting[frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Codice Python per inviare messagi su connessioni separate con chiamate a funzione in un loop.}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/benchmarks/send_multiple.py}

\lstinputlisting[frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Codice PASTEL per inviare messagi su una singola connessione con chiamate a funzione in un loop.}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/benchmarks/send_single.pa}

\lstinputlisting[frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Codice Python per inviare messagi su una singola connessione con chiamate a funzione in un loop.}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/benchmarks/send_single.py}

\end{document}          

% !TeX spellcheck = it_IT
\documentclass[]{article}
\usepackage{color, soul}
\newcommand{\hlc}[2][yellow]{ {\sethlcolor{#1} \hl{#2}} }
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{graphicx}



% Title Page
\title{PASTEL}
\author{{Augello Andrea} \and {Bafumo Francesco} \and{La Martina Marco}}


\begin{document}
\maketitle
\tableofcontents


\section{Introduzione}
PASTEL è stato pensato come un linguaggio di scripting per gestire e coordinare le interazioni tra dispositivi IoT basati su TCP.\\
L'utilizzo di PASTEL può essere vantaggioso in sistemi ciberfisici complessi che necessitano una conoscenza dello stato globale del sistema per coordinarsi. Infatti il sitema potrebbe includere dispositivi con risorse limitate e scarse capacità computazionali, che quindi non sono in grado di memorizzare lo stato del resto dei sensori ed effettuare decisioni complesse. 

Un altro contesto in cui PASTEL può essere utile è testare in modo replicabile il corretto comportamento interattivo di un sistema ciberfisico: il linguaggio proposto infatti può facilmente simulare l'output di molti sensori ed inviarlo agli attuatori.

Il resto della \hl{tesina} è strutturato come segue: la sezione~\ref{section:stato-arte} illustra il contesto in cui si colloca il linguaggio proposto, nella sezione~\ref{section:descrizione} vengono analizzati i dettagli implementativi, nella sezione~\ref{section:caratteristiche-linguaggio} si illustrano le caratteristiche di PASTEL e degli esempi di applicazioni, infine nella sezione~\ref{section:conclusioni} vengono riepilogati i punti principali del lavoro svolto.

\section{Stato dell'arte}\label{section:stato-arte}

I dispositivi IoT comunemente eseguono protocolli semplici come CoAP, REST e MQTT~\cite{tandale2017empirical}. \hlc[cyan]{[Inserire descrizione dei protocolli, magari qualche altra citazione]}

Il linguaggio proposto può facilmente essere utilizzato con i protocolli precedenti, eccetto CoAP poiché basato su UDP. L'ambiente target principale però è quello dei dispositivi in grado di eseguire codice simbolico~\cite{gaglio2017dc4cd} e su questi si incentreranno di casi d'uso nella sezione \ref{subsection:casi-d_uso}.  

[...]L'equivalente di \texttt{expect}~\cite{libes1991expect, libes1990expect} per reti di sensori wireless (WSN).

Alla luce di quanto detto, con questo linguaggio ci prefiggiamo l'obbiettivo di fornire uno strumento che permette di interfacciarsi con facilità e in modo affidabile con dispositivi IoT, [...]

\section{Descrizione del progetto}\label{section:descrizione}
\subsection{Analisi dei requisiti}
\subsection{Scelte progettuali}
\section{Caratteristiche del linguaggio}\label{section:caratteristiche-linguaggio}
\subsection{Grammatica}
\subsection{Descrizione del parser}
{[...]} Figura~\ref{fig:parser}[...]
\begin{figure}
	\centering
	\resizebox{\columnwidth}{!}{
	\includegraphics{sources/parser}}
	\caption{Grafico del FSA generato da Bison}
	\label{fig:parser}
\end{figure}

\subsection{Casi d'uso}\label{subsection:casi-d_uso}
\subsubsection{Network discovery}\label{subsubsection:net-disc}
In una rete di sensori generalmente è necessario che ogni nodo sappia quali sono i suoi vicini e come raggiungerli, a questo scopo sono stati sviluppati un grande numero di protocolli~\cite{narten1998neighbor, kandhalu2010u, alsa2012secure}.

In questo caso d'uso mostriamo come, con un codice relativamente compatto, a partire dalla conoscienza dell'indirizzo di un singolo nodo indicato con \texttt{root}, sia possibile ricostruire la topologia della porzione di rete connessa al nodo \texttt{root}.\\
Nel codice mostrato in~\ref{listing:net-disc} ogni nodo viene interrogato per ottenere la lista dei suoi vicini tramite la procedura \texttt{find\_neighbours}. Tutti i vicini del nodo che non sono già stati individuati precedentemente vengono aggiunti ad una lista di nodi noti.

Ogni nodo comunica la lista dei suoi vicini restituiendo in formato testuale indirizzo IP e numero di porta ai quali sono raggiungibili, separando i vari nodi con delle virgole. Il linguaggio PASTEL mette a disposizione funzioni bultin che permettono in modo estremamente semplice, a partire dai dati forniti in questo formato, di ottenere una lista PASTEL e convertire tutte le stringhe in device utilizzabili all'interno del programma.

L'algoritmo termina automaticamente nonappena l'ultimo dei nodi noti interrogato non restituisce nodi nuovi, a quel punto si saranno individuati tutti i nodi raggiungibili a partire da \texttt{root}.

Per semplicità si assume che il calcolatore che esegue il programma abbia un range di comunicazione molto superiore ai nodi della rete, e che possa quindi raggiungerli in un singolo hop, una strategia più generale dovrebbe ovviamente prevedere la costruzione di messaggi di routing.

\lstinputlisting[firstline=3, lastline=41, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Source code of \lstname}, label={listing:net-disc}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]{../testfiles/network_discovery.pa}

\subsubsection{Publish-Subscribe}\label{subsubsection:pub-sub}

Come visto precedentemente in~\cite{tandale2017empirical} il modello Publish-Subscribe è molto comune come protocollo di comunicazione nel campo IoT. Nel listato~\ref{listing:sub} mostriamo come PASTEL permetta con facilità di interrogare una lista di nodi per ottenere i topic a cui ogni nodo intende fare il subscribe, dopo questo step di configurazione è immediato poter mandare a tutti i nodi iscritti ad un topic un determinato messaggio.


\lstinputlisting[firstline=1, lastline=62, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Source code of \lstname}, label={listing:sub}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
 ]{../testfiles/subscriber.pa}


Con questo framework diventa estremamente facile per un nodo comunicare un messaggio da mandare a tutti i nodi iscritti ad un topic, come mostrato nel listato~\ref{listing:pub}.

Il programma si aspetta un input del tipo ``\texttt{<lista di topic> :TOPICS <messaggio>}'', la parte di messaggio che precede ``\texttt{:TOPICS}'' è interpretata come una lista di topic separati da virgole, il messaggio che segue quel tag, invece, verrà inviato a tutti i nodi che si sono precedentemente iscritti ad almeno uno di quei topic.

\lstinputlisting[firstline=1, lastline=29, frame=single, numbers=left, stepnumber=1, captionpos=b, caption={Source code of \lstname}, label={listing:pub}, breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
]{../testfiles/publisher.pa}

Lo schema di funzionamento illustrato può ovviamente essere ulteriormente raffinato impedendo l'iscrizione multipla ad uno stesso topic e aggiungendo controlli per evitare di inviare più volte uno stesso messaggio un nodo iscritto a più topic, o al nodo che ha originato il messaggio. Inoltre è possibile prevedere la possibilità di cancellare le iscrizioni o modificarle periodicamente.

\subsection{Risultati ottenuti}\label{subsection:risultati}

Il codice mostrato nelle sezioni~\ref{subsubsection:net-disc} e~\ref{subsubsection:pub-sub} mostra la potenzialità di essere integrato in un unico sistema software che, inserito in una rete, a partire dalla conoscenza di un singolo nodo, riesce a ricostruire la topologia della rete raggiungibile e gestire il funzionamento di un protocollo non banale del tipo publish-subscribe, dimostrando l'applicabilità del linguaggio proposto all'interno del contesto target. 

Per testare la scalabilità dell'implementazione del linguaggio abbiamo misurato il tempo impiegato per inviare un numero crescente di messaggi.\\
Un'invio di messaggio si riassume nelle seguenti operazioni:
\begin{enumerate}
	\item Si stabilisce una connessione.
	\item{Si verifica che la connessione abbia avuto successo.}
	\item Si invia il messaggio. 
	\item Si richiude la connessione.
\end{enumerate}

Al fine di ottenere risultati il più possibile realistici abbiamo usato tre schemi diversi con cui mandare i messaggi:
\begin{itemize}
	\item Ciclo ierativo: all'interno di un ciclo while vengono eseguite le operazioni sopra citate.
	\item Chiamate a funzione: all'interno di un ciclo while viene chiamata una funzione che effettua le operazioni di invio.
	\item Funzione ricorsiva: una funzione ha un parametro che conta quanti messaggi devono ancora essere inviati. Al termine dell'invio di un messaggio il parametro viene decrementato e si effettua una chiamata ricorsiva.
\end{itemize}

Il tempo impiegato è misurato utilizzando il programma di sistema \texttt{time}~\cite{time1linux}. Il tempo totale corrisponde al valore ``real'', mentre il tempo netto è la somma di ``user'' e ``sys''. I programmi eseguono una chiamata a \texttt{console()} che comporta un secondo di attesa per l'apertura del terminale.

\begin{table}[htbp]
	\centering
	\resizebox{\columnwidth}{!}{
	\begin{tabular}{|c| cc | cc| cc|}
		\hline
		                   & \multicolumn{2}{c|}{{\normalsize Ciclo iterativo }} & \multicolumn{2}{c|}{{\normalsize Chiamate a funzione }} & \multicolumn{2}{c|}{{\normalsize Ricorsione }} \\ \cline{2-7}
		Numero di messaggi & Tempo totale (s) &         Tempo netto (s)          & Tempo totale (s) &           Tempo netto (s)            & Tempo totale (s) &       Tempo netto (s)       \\ \hline
		        10         & 1.563            &              0.479               & 1.531            &                0.461                 & 3.168            &            0.099            \\
		        50         & 2.629            &              0.517               & 1.554            &                0.484                 & 3.166            &            0.102            \\
		       100         & 1.539            &              0.467               & 1.654            &                0.495                 & 5.192            &            0.104            \\
		       1000        & 2.659            &              0.544               & 1.726            &                0.581                 & 1.264            &            0.247            \\
		      10000        & 47.178           &              1.278               & 5.542            &                1.428                 & 18.718           &           13.194            \\ \hline
	\end{tabular}}
	\caption{Tempo necessario per l'invio di un numero crescente di messaggi}
	\label{table:performance}
\end{table}

Come si può vedere dalla tabella~\ref{table:performance} e in figura~\ref{fig:performance-graph} (si noti che gli assi sono in scala logaritmica), l'implementazione con la chiamata a funzione è quella con mediamente più veloce, anche se ha un tempo netto leggermente maggiore dell'implementazione puramente ricorsiva, anche se resta comparabile.

Una possibile spiegazione per questa peculiarità è che l'invio di messaggi è un processo molto IO-bound, quindi l'approccio iterativo è sufficientemente veloce da non trovare le risorse disponibili e viene sospeso aspettando un interrupt dal sistema operativo, incorrendo in numerosi context switch costosi. La chiamata a funzione, invece, ha dell'overhead per la creazione dello stack, questo, come si vede dal tempo netto, è abbastanza piccolo, ma potrebbe essere sufficientemente grande da evitare il context switch.

Questo dato sembra anche giustificare la scelta di sviluppare un linguaggio di scripting interpretato invece che un linguaggio compilato, visto che l'ambito di applicazione principale sarà legato all'invio di messaggi nella rete, e non elaborate manipolazioni dei dati.

Il tempo totale dell'implementazione ricorsiva è il maggiore di tutti\footnote{Su 10000 messaggi l'esecuzione è stata interrotta prematuramente dall'esaurimento della memoria a disposizione}, nonostante il numero di scope da creare sia lo stesso delle chiamate a funzione iterative, infatti, le ricerche dei simboli nello stack delle chimate a funzione diventano progressivamente più costose all'aumento delle chiamate ricorsive.

\begin{figure}
	\centering
	\resizebox{\columnwidth}{!}{
	\includegraphics{sources/performance-graph}}
	\caption{Performance dell'interprete}
	\label{fig:performance-graph}
\end{figure}


\section{Conclusioni}\label{section:conclusioni}




\bibliographystyle{unsrt}
\bibliography{references}

\end{document}          
